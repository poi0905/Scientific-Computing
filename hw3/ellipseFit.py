import numpy as np
from scipy import optimize
x = [float(val) for val in input().split()]
y = [float(val) for val in input().split()]
data = [x, y]


def ellipseFit(data):
    # 給定rx, ry來找cx, cy

    def f(center, x, y):
        r = sseOfEllipseFit(center, data)
        d = 0
        for i in range(len(x)):
            d += (((x[i] - center[0])/(r[0]))**2 + ((y[i] - center[1])/(r[1]))**2 - 1)**2
        return d

    center0 = [0, 0]  # initial guess: cx, cy = 0
    # 把initial guess 調整為所有點的平均
    for i in range(len(data[0])):
        center0[0] += (data[0][i] / len(data[0]))    # new cx
        center0[1] += (data[1][i] / len(data[0]))    # new cy
    center = optimize.fmin(f, center0, args=(x, y,), disp=False)
    r = sseOfEllipseFit(center, data)
    print(center[0], center[1], r[0][0], r[1][0])


def sseOfEllipseFit(center, data):
    # 製作矩陣 Ax = B
    A = np.zeros((len(data[0]), 2))
    B = np.ones((len(data[0]), 1))
    for i in range(len(data[0])):
        A[i][0] = (data[0][i] - center[0])**2
        A[i][1] = (data[1][i] - center[1])**2
    x, y = np.linalg.lstsq(A, B, rcond=None)[0]
    return (1/x)**(1/2), (1/y)**(1/2)   # rx, ry


if __name__ == '__main__':
    ellipseFit(data)


'''
19.5 4.4 18.1 5 0.5 19.2 0.4 18.7 8.1 -2.3 17.2 4.8 3.9 7.8 2.7 6.1 7.9 6.8 19.2 3.3 6.5 2.8 4.2 18 0.5 1.3 2 3.1 -1.5 3.7 10.1 -0 19.7 15 20.4 1.6 2.5 9.5 -2.5 8.3 17.2 8.5 1.7 19.2 19.5 0.1 20.6 -1 10.5 0.9 -1.4 1.5 1.4 18.8 14.5 -0.8 -2 18.9 19.7 -0.7 7.3 6.7 8.4 20.1 15.9 5.1 17.7 15.1 17.6 6.4 2.3 18.5 17.1 12.4 12.3 9.5 17.5 4.1 -0.9 1.6 18.7 -1 19.9 17.4 19.1 1.3 -0.3 7.2 3.3 6.9 -1.3 -2.6 19.4 6.3 -1.4 19.4 1.6 7.2 19 15 17.8 12.1 13.8 11.9 9.4 3.1 11.6 18.9 15.2 9.7 14.5 10.5 19.7 1.7 20.1 3 1.6 -1.9 14.1 -0.4 -1.9 18.6 2.8 18.1 19.7 10.1 -2.1 20.4 18.2 9.7 3.6 13.8 2.4 18.4 14.5 16.2 20.7 8.8 3.7 16.1 6.2 6.9 5.3 2.7 13.2 -0.5 6.4 -2.6 19.5 19.7 17.2 -1.6 1.7 -1.7 5.6 0.4 16 3.7 19.6 9.5 13.6 5.9 -1.7 17.5 19.1 4 5.1 17.4 0.6 19.8 9.3 19.2 9 10.1 14.3 13.3 9.7 8.3 2.4 -0.5 -0.9 13.3 4 17.4 9.1 16.7 -1.6 17.4 18.4 13.7 11.2 19.2 -0.7 5.8 6.7 19.1 16.3 5 0.6 -0 19 5.5 1.3 17.7 18.8 10.3 6.4 5.3 7.7 19.8 18.6 17.5 -0.7 16.2 3 5.7 18.4 18.3 17.4 15.3 8.5 15 4.3 11.8 6.6 5 -0.5 
3.5 -1.7 7.6 -1.7 -0.2 2.9 -0.4 2 -2.6 4.8 -0.2 12 10.8 -2.6 -1.2 -2.3 -2 -2.3 4 11.3 -1.2 11.4 10.6 10 1.6 0.3 10 11.2 3.3 11.6 -2.6 1.1 6.8 -0.7 7.3 9.8 10.2 -1.8 3.5 -2.2 9.3 11.6 -0.2 2.3 3.9 0.8 3 2.2 12.1 -0.6 3.5 9.9 10.8 0.7 -0.5 3.8 4.9 8 6.3 3.2 12.3 -2.1 -2 4.7 -1.1 11.8 -0.3 -1.6 1.4 -1.2 -0.1 2.7 9.6 11.7 11.8 11.3 1.3 -1.4 3.4 0 8.9 1.8 3.7 0.5 7.8 0.5 2.3 -2.3 11.3 -2 1 4.7 3.7 -1.3 4.3 1.5 -0.5 11.3 1.1 -0.1 9.3 11 10.8 -1.7 -2 -0.3 12.1 9.4 -0.7 -2.2 -1.4 12.2 4.3 10.1 7.2 -0.7 -0.3 4.1 11.6 1.8 3.3 7.5 11.5 9.9 5.4 -2.6 2.4 6.9 7.5 -1.7 10.5 -0.9 11.1 1.2 -1.1 9.8 5.1 12.6 -1.6 9.5 -1.7 -2.4 11.7 10.5 -1.5 1.5 11.3 3.6 1.3 6.3 10.4 4.1 9.7 1.8 11.4 1.8 9.7 -1.5 1.3 -1.8 -2 11.6 4.6 8.5 5.6 -1.6 11.9 0.6 0.7 4.3 -1.8 4.6 12.3 -1.7 11.3 -1.4 -2.1 12.1 -1.2 1.2 3.3 12.1 10.5 10.2 -1.6 9.7 3.6 -0.1 7.1 11.9 12.5 3.7 0.8 -2.4 -2.4 6.3 10 10.8 10.5 0.9 4.4 11.9 -0.3 1.5 7.7 -1.7 -1.4 -1.6 -2.6 7.4 1.4 8.9 1.3 9.7 -1 11.3 2.8 0.8 1.4 11.4 -1.4 -1.5 -1.2 -1.1 -1.4 11.1 2.8 
'''

'''
找cx cy rx ry
把四個參數拆成兩個是 linear parameter 兩個是 nonlinear
rx ry 就是線性的參數
cx cy 就是非線性的參數 -> downhill simplex search
在搜尋的過程中 一旦cx cy一給定
rx ry 就能用LSE來做
也就是說要最佳化的目標只有cx cy函數
'''